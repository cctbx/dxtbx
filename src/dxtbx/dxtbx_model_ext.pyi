from typing import (
    Any,
    Dict,
    Generic,
    Iterator,
    List,
    Optional,
    Tuple,
    TypeVar,
    Union,
    overload,
)

from cctbx.sgtbx import space_group
from cctbx.uctbx import unit_cell
from scitbx.array_family import flex

# MinusY: KappaDirection
# MinusZ: KappaDirection
# Omega: KappaScanAxis
# Phi: KappaScanAxis
# PlusY: KappaDirection
# PlusZ: KappaDirection

try:
    # Attempt to use the stub typing for flex-inheritance
    from scitbx.array_family.flex import FlexPlain
except ImportError:
    # Maybe scitbx-stubs isn't installed... fallback for now
    VT = TypeVar("VT")
    class FlexPlain(Generic[VT]):
        pass

Vec2Float = Tuple[float, float]
Vec3Float = Tuple[float, float, float]
Vec6Float = Tuple[float, float, float, float, float, float]
Vec9Float = Tuple[float, float, float, float, float, float, float, float, float]
Vec2Int = Tuple[int, int]
Vec4Int = Tuple[int, int, int, int]

class BeamBase:
    @property
    def num_scan_points(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def get_divergence(self) -> float: ...
    def set_divergence(self, divergence: float) -> None: ...
    def get_flux(self) -> float: ...
    def set_flux(self, flux: float) -> None: ...
    def get_num_scan_points(self) -> int: ...
    def get_polarization_fraction(self) -> float: ...
    def set_polarization_fraction(self, polarization_fraction: float) -> None: ...
    def get_polarization_normal(self) -> Vec3Float: ...
    def set_polarization_normal(self, polarization_normal: Vec3Float) -> None: ...
    def get_s0(self) -> Vec3Float: ...
    def set_s0(self, s0: Vec3Float) -> None: ...
    def get_s0_at_scan_point(self, index: int) -> Vec3Float: ...
    def get_s0_at_scan_points(self) -> flex.vec3_double: ...
    @overload
    def set_s0_at_scan_points(self, points: List[Vec3Float]) -> None: ...
    @overload
    def set_s0_at_scan_points(self, points: Tuple[Vec3Float]) -> None: ...
    def get_sample_to_source_direction(self) -> Vec3Float: ...
    def get_sigma_divergence(self) -> float: ...
    def set_sigma_divergence(self, sigma_divergence: float) -> None: ...
    def get_transmission(self) -> float: ...
    def set_transmission(self, transmission: float) -> None: ...
    def get_unit_s0(self) -> Vec3Float: ...
    def set_unit_s0(self, unit_s0: Vec3Float) -> None: ...
    def get_wavelength(self) -> float: ...
    def set_wavelength(self, wavelength: float) -> None: ...
    def is_similar_to(
        self,
        other: BeamBase,
        wavelength_tolerance: float = ...,
        direction_tolerance: float = ...,
        polarization_normal_tolerance: float = ...,
        polarization_fraction_tolerance: float = ...,
    ) -> bool: ...
    def reset_scan_points(self) -> None: ...
    def rotate_around_origin(
        self, axis: Vec3Float, angle: float, deg: bool = ...
    ) -> Any: ...
    def set_direction(self, direction: Vec3Float) -> None: ...

class Beam(BeamBase):
    @overload
    def __init__(self, beam: Beam) -> None: ...
    @overload
    def __init__(self, direction: Vec3Float, wavelength: float) -> None: ...
    @overload
    def __init__(self, s0: Vec3Float) -> None: ...
    @overload
    def __init__(
        self,
        direction: Vec3Float,
        wavelength: float,
        divergence: float,
        sigma_divergence: float,
        deg: bool = ...,
    ) -> None: ...
    @overload
    def __init__(
        self, s0: Vec3Float, divergence: float, sigma_divergence: float, deg: bool = ...
    ) -> None: ...
    @overload
    def __init__(
        self,
        direction: Vec3Float,
        wavelength: float,
        divergence: float,
        sigma_divergence: float,
        polarization_normal: Vec3Float,
        polarization_fraction: float,
        flux: float,
        transmission: float,
        deg: bool = ...,
    ) -> None: ...
    def from_dict(self, Dict) -> Beam: ...
    def to_dict(self) -> Dict: ...

class CrystalBase:
    @property
    def num_scan_points(self) -> int: ...
    def change_basis(self, cctbx) -> Any: ...
    def get_A(self) -> Vec9Float: ...
    def get_B(self) -> Vec9Float: ...
    def get_U(self) -> Vec9Float: ...
    def set_A(self, A: Vec9Float) -> None: ...
    def set_B(self, B: Vec9Float) -> None: ...
    def set_U(self, U: Vec9Float) -> None: ...
    def get_A_at_scan_point(self, index: int) -> Vec9Float: ...
    def get_B_at_scan_point(self, index: int) -> Vec9Float: ...
    def get_B_covariance(self) -> flex.double: ...
    def get_B_covariance_at_scan_point(self, index: int) -> flex.double: ...
    def get_B_covariance_at_scan_points(self) -> flex.double: ...
    def get_U_at_scan_point(self, index: int) -> Vec9Float: ...
    def get_cell_parameter_sd(self) -> Vec6Float: ...
    def get_cell_parameter_sd_at_scan_point(self, index: int) -> Vec6Float: ...
    def get_cell_volume_sd(self) -> float: ...
    def get_num_scan_points(self) -> int: ...
    def get_real_space_vectors(self) -> flex.vec3_double: ...
    def get_recalculated_cell_parameter_sd(self) -> Vec6Float: ...
    def get_recalculated_cell_volume_sd(self) -> float: ...
    def get_recalculated_unit_cell(self) -> Optional[unit_cell]: ...
    def get_unit_cell(self) -> unit_cell: ...
    def get_space_group(self) -> space_group: ...
    def get_unit_cell_at_scan_point(self, index: int) -> unit_cell: ...
    def is_similar_to(
        self,
        other: CrystalBase,
        angle_tolerance: float = ...,
        uc_rel_length_tolerance: float = ...,
        uc_abs_angle_tolerance: float = ...,
    ) -> bool: ...
    def reset_scan_points(self) -> None: ...
    def reset_unit_cell_errors(self) -> None: ...
    def rotate_around_origin(
        self, axis: Vec3Float, angle: float, deg: bool = ...
    ) -> Any: ...
    @overload
    def set_A_at_scan_points(self, value: List[Vec9Float]) -> None: ...
    @overload
    def set_A_at_scan_points(self, value: Tuple[Vec9Float]) -> None: ...
    @overload
    def set_A_at_scan_points(self, value: flex.mat3_double) -> None: ...
    @overload
    def set_B_covariance(self, covariance: flex.double) -> None: ...
    @overload
    def set_B_covariance(self, covariance: Tuple[float, ...]) -> None: ...
    def set_B_covariance_at_scan_points(self, data: flex.double) -> None: ...
    def set_recalculated_cell_parameter_sd(self, value: Vec6Float) -> None: ...
    def set_recalculated_cell_volume_sd(self, volume: float) -> None: ...
    def set_recalculated_unit_cell(self, unit_cell: unit_cell) -> None: ...
    def set_space_group(self, space_group: space_group) -> None: ...
    def set_unit_cell(self, unit_cell: unit_cell) -> None: ...
    def update(self, other: CrystalBase) -> None: ...
    def update_B(self) -> None: ...

class Crystal(CrystalBase):
    @overload
    def __init__(self, other: Crystal) -> None: ...
    @overload
    def __init__(
        self,
        real_space_a: float,
        real_space_b: float,
        real_space_c: float,
        space_group: space_group,
    ) -> None: ...
    @overload
    def __init__(
        self,
        real_space_a: float,
        real_space_b: float,
        real_space_c: float,
        space_group_symbol: str,
    ) -> None: ...
    @overload
    def __init__(
        self, A: Vec9Float, space_group: space_group, reciprocal: bool = ...
    ) -> None: ...
    @overload
    def __init__(
        self, A: Vec9Float, space_group_symbol: str, reciprocal: bool = ...
    ) -> None: ...

class Detector:
    def __init__(self, panel: Panel) -> None: ...
    def hierarchy(self) -> DetectorNode: ...
    @overload
    def add_group(self) -> DetectorNode: ...
    @overload
    def add_group(self, group: Panel) -> DetectorNode: ...
    @overload
    def add_panel(self) -> Panel: ...
    @overload
    def add_panel(self, panel: Panel) -> Panel: ...
    def from_dict(self, data: Dict) -> Detector: ...
    def to_dict(self) -> Dict: ...
    def get_max_inscribed_resolution(self, s0: Vec3Float) -> float: ...
    def get_max_resolution(self, s0: Vec3Float) -> float: ...
    def get_names(self) -> flex.std_string: ...
    def get_panel_intersection(self, s1: Vec3Float) -> int: ...
    def get_ray_intersection(self, s1: Vec3Float) -> Tuple[int, Vec2Float]: ...
    def has_projection_2d(self) -> bool: ...
    def is_similar_to(
        self,
        other: Detector,
        fast_axis_tolerance: float = ...,
        slow_axis_tolerance: float = ...,
        origin_tolerance: float = ...,
        static_only: bool = ...,
        ignore_trusted_range: bool = ...,
    ) -> bool: ...
    def rotate_around_origin(
        self, axis: Vec3Float, angle: float, deg: bool = ...
    ) -> Any: ...
    def __getitem__(self, index: int) -> Panel: ...
    def __setitem__(self, index: int, panel: Panel) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(boost) -> Iterator[DetectorNode]: ...
    def __eq__(self, other: Detector) -> bool: ...
    def __ne__(self, other: Detector) -> bool: ...

class Experiment:
    beam: Any
    crystal: Any
    detector: Any
    goniometer: Any
    identifier: Any
    imageset: Any
    profile: Any
    scaling_model: Any
    scan: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def is_consistent(self) -> Any: ...
    def is_sequence(self) -> Any: ...
    def is_still(self) -> Any: ...
    def __contains__(self, boost) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __getinitargs__(self) -> Any: ...
    def __reduce__(self) -> Any: ...

class ExperimentList:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, *args, **kwargs) -> Any: ...
    def clear(self) -> Any: ...
    def empty(self) -> Any: ...
    def extend(self, *args, **kwargs) -> Any: ...
    def find(self, *args, **kwargs) -> Any: ...
    def identifiers(self) -> Any: ...
    def indices(self, boost) -> Any: ...
    def is_consistent(self) -> Any: ...
    def remove_on_experiment_identifiers(self, boost) -> Any: ...
    def replace(self, *args, **kwargs) -> Any: ...
    def select_on_experiment_identifiers(self, boost) -> Any: ...
    def where(self) -> Any: ...
    def __contains__(self, boost) -> bool: ...
    def __delitem__(self, int) -> Any: ...
    def __getinitargs__(self) -> Any: ...
    def __getitem__(self, index: int) -> Experiment: ...
    def __iter__(boost) -> Any: ...
    def __len__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...

# class Goniometer(GoniometerBase):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def from_dict(self, *args, **kwargs) -> Any: ...
#     def get_fixed_rotation(self) -> Any: ...
#     def get_num_scan_points(self) -> Any: ...
#     def get_rotation_axis(self) -> Any: ...
#     def get_rotation_axis_datum(self) -> Any: ...
#     def get_setting_rotation(self) -> Any: ...
#     def get_setting_rotation_at_scan_point(self, unsignedlong) -> Any: ...
#     def get_setting_rotation_at_scan_points(self) -> Any: ...
#     def is_similar_to(self, *args, **kwargs) -> Any: ...
#     def reset_scan_points(self) -> Any: ...
#     def rotate_around_origin(self, *args, **kwargs) -> Any: ...
#     def set_fixed_rotation(self, scitbx) -> Any: ...
#     def set_rotation_axis(self, scitbx) -> Any: ...
#     def set_rotation_axis_datum(self, scitbx) -> Any: ...
#     def set_setting_rotation(self, scitbx) -> Any: ...
#     @overload
#     def set_setting_rotation_at_scan_points(self, boost) -> Any: ...
#     @overload
#     def set_setting_rotation_at_scan_points(self, boost) -> Any: ...
#     def to_dict(self) -> Any: ...
#     def __eq__(self, other) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __getstate__(boost) -> Any: ...
#     def __ne__(self, other) -> Any: ...
#     def __reduce__(self) -> Any: ...
#     def __setstate__(self, state) -> Any: ...
#     @property
#     def num_scan_points(self) -> Any: ...

# class GoniometerBase:
#     def __init__(self, *args, **kwargs) -> None: ...
#     def __reduce__(self) -> Any: ...

# class KappaDirection(Boost.Python.enum):
#     MinusY: ClassVar[KappaDirection] = ...
#     MinusZ: ClassVar[KappaDirection] = ...
#     PlusY: ClassVar[KappaDirection] = ...
#     PlusZ: ClassVar[KappaDirection] = ...
#     names: ClassVar[dict] = ...
#     values: ClassVar[dict] = ...

# class KappaGoniometer(Goniometer):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def get_alpha_angle(self) -> Any: ...
#     def get_direction(self) -> Any: ...
#     def get_kappa_angle(self) -> Any: ...
#     def get_kappa_axis(self) -> Any: ...
#     def get_omega_angle(self) -> Any: ...
#     def get_omega_axis(self) -> Any: ...
#     def get_phi_angle(self) -> Any: ...
#     def get_phi_axis(self) -> Any: ...
#     def get_scan_axis(self) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __reduce__(self) -> Any: ...

# class KappaScanAxis(Boost.Python.enum):
#     Omega: ClassVar[KappaScanAxis] = ...
#     Phi: ClassVar[KappaScanAxis] = ...
#     names: ClassVar[dict] = ...
#     values: ClassVar[dict] = ...

# class MosaicCrystalKabsch2010(Crystal):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def get_mosaicity(self) -> Any: ...
#     def is_similar_to(self, *args, **kwargs) -> Any: ...
#     def set_mosaicity(self, *args, **kwargs) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __getstate__(boost) -> Any: ...
#     def __reduce__(self) -> Any: ...
#     def __setstate__(self, state) -> Any: ...

# class MosaicCrystalSauter2014(Crystal):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def get_domain_size_ang(self) -> Any: ...
#     def get_half_mosaicity_deg(self) -> Any: ...
#     def is_similar_to(self, *args, **kwargs) -> Any: ...
#     def set_domain_size_ang(self, double) -> Any: ...
#     def set_half_mosaicity_deg(self, double) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __getstate__(boost) -> Any: ...
#     def __reduce__(self) -> Any: ...
#     def __setstate__(self, state) -> Any: ...

# class MultiAxisGoniometer(Goniometer):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def from_dict(self, *args, **kwargs) -> Any: ...
#     def get_angles(self) -> Any: ...
#     def get_axes(self) -> Any: ...
#     def get_names(self) -> Any: ...
#     def get_scan_axis(self) -> Any: ...
#     def set_angles(self, scitbx) -> Any: ...
#     def set_axes(self, *args, **kwargs) -> Any: ...
#     def to_dict(self) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __getstate__(boost) -> Any: ...
#     def __reduce__(self) -> Any: ...
#     def __setstate__(self, state) -> Any: ...

# class OffsetParallaxCorrectedPxMmStrategy(ParallaxCorrectedPxMmStrategy):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def dx(self) -> Any: ...
#     def dy(self) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __reduce__(self) -> Any: ...

# class OffsetPxMmStrategy(PxMmStrategy):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def dx(self) -> Any: ...
#     def dy(self) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __reduce__(self) -> Any: ...

class Panel:
    @overload
    def __init__(
        self,
        type: str,
        name: str,
        fast_axis: Vec3Float,
        slow_axis: Vec3Float,
        origin: Vec3Float,
        pixel_size: Vec2Float,
        image_size: Tuple[int, int],
        trusted_range: Vec2Float,
        thickness: float,
        material: str,
        mu: float,
        identifier: str = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        type: str,
        name: str,
        fast_axis: Vec3Float,
        slow_axis: Vec3Float,
        origin: Vec3Float,
        pixel_size: Vec2Float,
        image_size: Tuple[int, int],
        trusted_range: Vec2Float,
        thickness: float,
        material: str,
        px_mm: PxMmStrategy,
        mu: float,
        identifier: str = ...,
    ) -> None: ...
    @overload
    def from_dict(self, data: Dict) -> Panel: ...
    @overload
    def from_dict(self, data: Dict, dx: flex.double, dy: flex.double) -> Panel: ...
    def get_beam_centre_px(self, s0: Vec3Float) -> Vec2Float: ...
    def get_bidirectional_ray_intersection_px(self, s1: Vec3Float) -> Vec2Float: ...
    def get_cos2_two_theta_array(self, s0: Vec3Float) -> flex.double: ...
    def get_gain(self) -> float: ...
    def get_identifier(self) -> str: ...
    def get_image_size_mm(self) -> Vec2Float: ...
    def get_max_resolution_at_corners(self, s0: Vec3Float) -> float: ...
    def get_max_resolution_ellipse(self, s0: Vec3Float) -> float: ...
    def get_normal_origin_px(self) -> Vec2Float: ...
    def get_pedestal(self) -> float: ...
    def get_pixel_lab_coord(self, px: Vec2Float) -> Vec3Float: ...
    def get_projection_2d(self) -> Union[Tuple[Vec4Int, Vec2Int], Tuple[()]]: ...
    def get_px_mm_strategy(self) -> PxMmStrategy: ...
    def get_ray_intersection_px(self, s1: Vec3Float) -> Vec2Float: ...
    def get_resolution_at_pixel(self, s0: Vec3Float, xy: Vec2Float) -> float: ...
    @overload
    def get_trusted_range_mask(self, image: flex.double) -> flex.bool: ...
    @overload
    def get_trusted_range_mask(self, image: flex.int) -> flex.bool: ...
    def get_two_theta_array(self, s0: Vec3Float) -> flex.double: ...
    def get_two_theta_at_pixel(self, s0: Vec3Float, xy: Vec2Float) -> float: ...
    def get_untrusted_rectangle_mask(self) -> flex.bool: ...
    def is_(self, other: Panel) -> bool: ...
    def is_coord_valid(self, xy: Vec2Float) -> bool: ...
    def is_coord_valid_mm(self, xy: Vec2Float) -> bool: ...
    def is_value_in_trusted_range(self, value: float) -> bool: ...
    @overload
    def millimeter_to_pixel(self, xy: Vec2Float) -> Vec2Float: ...
    @overload
    def millimeter_to_pixel(self, xy: flex.vec2_double) -> flex.vec2_double: ...
    @overload
    def pixel_to_millimeter(self, xy: Vec2Float) -> Vec2Float: ...
    @overload
    def pixel_to_millimeter(self, xy: flex.vec2_double) -> flex.vec2_double: ...
    def rotate_around_origin(
        self, axis: Vec3Float, angle: float, deg: bool = ...
    ) -> None: ...
    def set_gain(self, gain: float) -> None: ...
    def set_identifier(self, identifier: str) -> None: ...
    def set_pedestal(self, pedestal: float) -> None: ...
    def set_projection_2d(self, rotation: Vec4Int, translation: Vec2Int) -> None: ...
    def set_px_mm_strategy(self, strategy: PxMmStrategy) -> None: ...
    def to_dict(self) -> Dict: ...
    def __eq__(self, other: Panel) -> bool: ...
    def __ne__(self, other: Panel) -> bool: ...

class DetectorNode(Panel):
    @overload
    def add_group(self) -> DetectorNode: ...
    @overload
    def add_group(self, group: Panel) -> DetectorNode: ...
    @overload
    def add_panel(self) -> Panel: ...
    @overload
    def add_panel(self, panel: Panel) -> Panel: ...
    def children(self) -> Iterator[DetectorNode]: ...
    def empty(self) -> bool: ...
    def index(self) -> int: ...
    def is_group(self) -> bool: ...
    def is_panel(self) -> bool: ...
    def is_similar_to(
        self,
        other: DetectorNode,
        fast_axis_tolerance: float = ...,
        slow_axis_tolerance: float = ...,
        origin_tolerance: float = ...,
        static_only: bool = ...,
        ignore_trusted_range: bool = ...,
    ) -> bool: ...
    def parent(self) -> DetectorNode: ...
    def root(self) -> DetectorNode: ...
    def set_frame(
        self, fast_axis: Vec3Float, slow_axis: Vec3Float, origin: Vec3Float
    ) -> None: ...
    def set_local_frame(
        self, fast_axis: Vec3Float, slow_axis: Vec3Float, origin: Vec3Float
    ) -> None: ...
    def set_parent_frame(
        self, fast_axis: Vec3Float, slow_axis: Vec3Float, origin: Vec3Float
    ) -> None: ...
    def __eq__(self, other: DetectorNode) -> bool: ...
    def __ne__(self, other: DetectorNode) -> bool: ...
    def __getitem__(self, index: int) -> DetectorNode: ...
    def __iter__(boost) -> Iterator[DetectorNode]: ...
    def __len__(self) -> int: ...

# class ParallaxCorrectedPxMmStrategy(SimplePxMmStrategy):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def mu(self) -> Any: ...
#     def t0(self) -> Any: ...
#     def __eq__(self, other) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     def __ne__(self, other) -> Any: ...
#     def __reduce__(self) -> Any: ...

class PxMmStrategy:
    def __init__(self, *args, **kwargs) -> None: ...
    def name(self) -> Any: ...
    def to_millimeter(self, *args, **kwargs) -> Any: ...
    def to_pixel(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...

# class Scan(ScanBase):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def append(self, *args, **kwargs) -> Any: ...
#     def from_dict(self, *args, **kwargs) -> Any: ...
#     def get_angle_from_array_index(self, *args, **kwargs) -> Any: ...
#     def get_angle_from_image_index(self, *args, **kwargs) -> Any: ...
#     def get_array_index_from_angle(self, *args, **kwargs) -> Any: ...
#     def get_array_indices_with_angle(self, *args, **kwargs) -> Any: ...
#     def get_array_range(self) -> Any: ...
#     def get_batch_for_array_index(self, int) -> Any: ...
#     def get_batch_for_image_index(self, int) -> Any: ...
#     def get_batch_offset(self) -> Any: ...
#     def get_batch_range(self) -> Any: ...
#     def get_epochs(self) -> Any: ...
#     def get_exposure_times(self) -> Any: ...
#     def get_image_epoch(self, int) -> Any: ...
#     def get_image_index_from_angle(self, *args, **kwargs) -> Any: ...
#     def get_image_indices_with_angle(self, *args, **kwargs) -> Any: ...
#     def get_image_oscillation(self, *args, **kwargs) -> Any: ...
#     def get_image_range(self) -> Any: ...
#     def get_num_images(self) -> Any: ...
#     def get_oscillation(self) -> Any: ...
#     def get_oscillation_range(self) -> Any: ...
#     def get_valid_image_ranges(self, *args, **kwargs) -> Any: ...
#     def is_angle_valid(self, *args, **kwargs) -> Any: ...
#     def is_array_index_valid(self, double) -> Any: ...
#     def is_batch_valid(self, int) -> Any: ...
#     def is_image_index_valid(self, double) -> Any: ...
#     def is_still(self) -> Any: ...
#     def set_batch_offset(self, int) -> Any: ...
#     def set_epochs(self, scitbx) -> Any: ...
#     def set_exposure_times(self, scitbx) -> Any: ...
#     def set_image_range(self, scitbx) -> Any: ...
#     def set_oscillation(self, scitbx) -> Any: ...
#     def set_valid_image_ranges(self, *args, **kwargs) -> Any: ...
#     def swap(self, *args, **kwargs) -> Any: ...
#     def to_dict(self) -> Any: ...
#     def __add__(self, other) -> Any: ...
#     def __copy__(self) -> Any: ...
#     def __deepcopy__(self, boost) -> Any: ...
#     def __eq__(self, other) -> Any: ...
#     def __ge__(self, other) -> Any: ...
#     def __getinitargs__(self) -> Any: ...
#     @overload
#     def __getitem__(self, int) -> Any: ...
#     @overload
#     def __getitem__(self, boost) -> Any: ...
#     def __gt__(self, other) -> Any: ...
#     def __iadd__(boost, dxtbx) -> Any: ...
#     def __le__(self, other) -> Any: ...
#     def __len__(self) -> Any: ...
#     def __lt__(self, other) -> Any: ...
#     def __ne__(self, other) -> Any: ...
#     def __reduce__(self) -> Any: ...

# class ScanBase:
#     def __init__(self, *args, **kwargs) -> None: ...
#     def __reduce__(self) -> Any: ...

# class SimplePxMmStrategy(PxMmStrategy):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def __getinitargs__(self) -> Any: ...
#     def __reduce__(self) -> Any: ...

class Spectrum:
    @overload
    def __init__(self, other: Spectrum) -> None: ...
    @overload
    def __init__(self, energies: flex.double, weights: flex.double) -> None: ...
    def from_dict(self, Dict) -> Spectrum: ...
    def get_emax_eV(self) -> float: ...
    def get_emin_eV(self) -> float: ...
    def get_energies_eV(self) -> flex.double: ...
    def get_weighted_energy_eV(self) -> float: ...
    def get_weighted_energy_variance(self) -> float: ...
    def get_weighted_wavelength(self) -> float: ...
    def get_weights(self) -> flex.double: ...
    def to_dict(self) -> Dict: ...

# class VirtualPanel(VirtualPanelFrame):
#     def __init__(self, *args, **kwargs) -> None: ...
#     def get_name(self) -> Any: ...
#     def get_type(self) -> Any: ...
#     def set_name(self, *args, **kwargs) -> Any: ...
#     def set_type(self, *args, **kwargs) -> Any: ...
#     def __eq__(self, other) -> Any: ...
#     def __ne__(self, other) -> Any: ...
#     def __reduce__(self) -> Any: ...

# class VirtualPanelFrame:
#     def __init__(self, *args, **kwargs) -> None: ...
#     def get_D_matrix(self) -> Any: ...
#     def get_beam_centre(self, scitbx) -> Any: ...
#     def get_beam_centre_lab(self, scitbx) -> Any: ...
#     def get_bidirectional_ray_intersection(self, scitbx) -> Any: ...
#     def get_d_matrix(self) -> Any: ...
#     def get_directed_distance(self) -> Any: ...
#     def get_distance(self) -> Any: ...
#     def get_fast_axis(self) -> Any: ...
#     def get_lab_coord(self, scitbx) -> Any: ...
#     def get_local_d_matrix(self) -> Any: ...
#     def get_local_fast_axis(self) -> Any: ...
#     def get_local_origin(self) -> Any: ...
#     def get_local_slow_axis(self) -> Any: ...
#     def get_normal(self) -> Any: ...
#     def get_normal_origin(self) -> Any: ...
#     def get_origin(self) -> Any: ...
#     def get_parent_d_matrix(self) -> Any: ...
#     def get_parent_fast_axis(self) -> Any: ...
#     def get_parent_origin(self) -> Any: ...
#     def get_parent_slow_axis(self) -> Any: ...
#     def get_ray_intersection(self, scitbx) -> Any: ...
#     def get_slow_axis(self) -> Any: ...
#     def set_frame(self, *args, **kwargs) -> Any: ...
#     def set_local_frame(self, *args, **kwargs) -> Any: ...
#     def set_parent_frame(self, *args, **kwargs) -> Any: ...
#     def __eq__(self, other) -> Any: ...
#     def __ne__(self, other) -> Any: ...
#     def __reduce__(self) -> Any: ...

class flex_Beam(FlexPlain[Beam]):
    pass

class flex_Spectrum(FlexPlain[Spectrum]):
    pass

# def get_mod2pi_angles_in_range(*args, **kwargs) -> Any: ...
# def get_range_of_mod2pi_angles(*args, **kwargs) -> Any: ...
# def is_angle_in_range(*args, **kwargs) -> Any: ...
# def parallax_correction(*args, **kwargs) -> Any: ...
# def parallax_correction_inv(*args, **kwargs) -> Any: ...
